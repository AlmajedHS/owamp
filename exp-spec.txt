/*
 *      $Id$
 */
/************************************************************************
*									*
*			     Copyright (C)  2002			*
*				Internet2				*
*			     All Rights Reserved			*
*									*
************************************************************************/
/*
 *	File:		exp-spec.txt
 *
 *	Author:		Anatoly Karp
 *			Internet2
 *
 *	Date:		Sun Jun 20 12:29:20 MDT 2002
 *
 *	Description:    Part of OWAMP specification describing
 *			generation of uniform(0,1) and	 
 *			exponential (mean 1) random variates in	 
 *                      [32].[32] format.                        
 */

This part of the document describes in greater detail the way
exponential random quantities used in the protocol are generated.
The following is algorithm 3.4.1.S in volume 2 of "The Art of
Computer Programming" (1998) by D.Knuth, the way its use is
prescribed by this RFC. It produces exponential (mean mu)
random deviates.

Algorithm S: the constants

Q[k] = (ln2)/(1!) + (ln2)^2/(2!) + ... + (ln2)^k/(k!),    1 <= k <= K-1

are precomputed. NOTE: all scalar quantities and arithmetical
operations are in fixed-precision 64-bit arithmetic (32 bits before
and after the decimal point). Implementation of arithmetic (only
multiplication and addition are needed) is given below.  All 32-bit
uniform random strings are obtained by applying AES in counter mode to
a 128-bit unsigned integer (initialized to be zero) written in network
byte order, then picking the i_th quartet of bytes of the encrypted
block, where i is equal to the value of the counter modulo 4. (Thus,
one encrypted block gives rise to four 32-bit random strings)

S1. [Get U and shift.] Generate a 32-bit uniform random binary fraction

              U = (.b0 b1 b2 ... b31)    [note the decimal point]

    Locate the first zero bit b_j, and shift off the leading (j+1) bits,
    setting U <- (.b_{j+1} ... b31)

    NOTE: in the rare case that the zero has not been found it is prescribed
    that the algorithm return (mu*32*ln2).

S2. [Immediate acceptance?] If U < ln2, set X <- mu*(j*ln2 + U) and terminate
    the algorithm. (Note that Q[1] = ln2.)

S3. [Minimize.] Find the least k >= 2 sich that U < Q[k]. Generate
    k new uniform random binary fractions U1,...,Uk and set
    V <- min(U1,...,Uk).

S4. [Deliver the answer.] Set X <- mu*(j + V)*ln2.

The algorithm and the code below rely upon two primitives from
rijndael. Their prototypes and specification are given below, and they
are provided by every rijndael implementation, such as the reference
implementation available at

http://www.esat.kuleuven.ac.be/~rijmen/rijndael/rijndaelref.zip:

1. this function initializes 'key' with bytes from 'seed'

    void
    rijndaelKeyInit(keyInstance key, BYTE seed[16]);

2. this function encrypts the 16-byte block 'inblock' with
   the 'key', putting the result in 'outblock'

   void
   rijndaelBlockEncrypt(keyInstance *key, BYTE inblock[16], BYTE outblock[16]);

/*
** Example usage: generate a stream of exponential (mean 1)
** random quantities (ignoring error checking during initialization).
   First initialize using a 128-bit seed (16-digit hex number).
**
** unsigned char seed[] = "fa91b3d691c2d36d7a91c6d691c2d36d";
** OWPrand_context64 next;
** OWPrand_context64_init(&next, seed);
**
** while (1) {
**    OWPnum64 num = OWPexp_rand64(&next);
      <do something with num here>
                 ...
** }
*/

#include <stdlib.h>
#include <stdio.h>
#include "rijndael-alg-fst.h"

typedef u_int64_t OWPnum64;

#define K 12 /* So (K - 1) is the first k such that Q[k] > 1 - 1/(2^32). */

#define MASK32(x) ((x) & 0xFFFFFFFF)

typedef struct OWPrand_context64 {
	unsigned char counter[16]; /* 128-bit counter (network byte ordered) */
	keyInstance key;           /* key used to encrypt the counter.       */
	BYTE out[16];              /* the encrypted block is kept there.     */
} OWPrand_context64;

/*
** The array has been computed according to the formula:
**
**       Q[k] = (ln2)/(1!) + (ln2)^2/(2!) + ... + (ln2)^k/(k!)
**
** as described in the Knuth algorithm. (The values below have been
** multiplied by 2^32 and rounded to the nearest integer.)
*/
static OWPnum64 Q[K] = {
	0,          /* Placeholder. */
	0xB17217F8,
	0xEEF193F7,
	0xFD271862,
	0xFF9D6DD0,
	0xFFF4CFD0,
	0xFFFEE819,
	0xFFFFE7FF,
	0xFFFFFE2B,
	0xFFFFFFE0,
	0xFFFFFFFE,
	0xFFFFFFFF
};

#define LN2 Q[1] /* this element represents ln2 */

/* 
** Convert an unsigned 32-bit integer into a OWPnum64 struct..
*/
OWPnum64
OWPulong2num64(u_int32_t a)
{
	return ((u_int64_t)1 << 32) * a;
}

/*
** Arithmetic functions on OWPnum64 numbers.
*/

/*
** Addition.
*/
OWPnum64
OWPnum64_add(OWPnum64 x, OWPnum64 y)
{
	return x + y;
}

/*
** Multiplication. Allows overflow. Straightforward implementation
** of Knuth vol.2 Algorithm 4.3.1.M (p.268)
*/
OWPnum64
OWPnum64_mul(OWPnum64 x, OWPnum64 y)
{
	unsigned long w[4];
	u_int64_t xdec[2];
	u_int64_t ydec[2];

	int i, j;
	u_int64_t k, t;
	OWPnum64 ret;

	xdec[0] = x & 0xFFFFFFFF;
	xdec[1] = x >> 32;
	ydec[0] = y & 0xFFFFFFFF;
	ydec[1] = y >> 32;

	for (j = 0; j < 4; j++)
		w[j] = 0; 

	for (j = 0;  j < 2; j++) {
		k = 0;
		for (i = 0; ; ) {
			t = k + (xdec[i]*ydec[j]) + w[i + j];
			w[i + j] = t%0xFFFFFFFF;
			k = t/0xFFFFFFFF;
			if (++i < 2)
				continue;
			else {
				w[j + 2] = k;
				break;
			}
		}
	}

	ret = w[2];
	ret <<= 32;
	return w[1] + ret;
}



/*
** This function converts a 32-bit binary string (network byte order)
** into a OWPnum64 number (32 least significant bits).
*/
static OWPnum64
OWPraw2num64(const unsigned char *raw)
{
	return ((u_int32_t)(raw[0]) << 24) 
		+ ((u_int32_t)(raw[1]) << 16) 
		+ ((u_int32_t)(raw[2]) << 8) 
		+ (u_int32_t)raw[3];
}

/*
** Random number generating functions.
*/

/*
** Generate and return a 32-bit uniform random string (saved in the lower
** half of the OWPnum64.
*/
OWPnum64
OWPunif_rand64(OWPrand_context64 *next)
{
	int j;
	u_int8_t res = next->counter[15] & (u_int8_t)3;

	if (!res)
		rijndaelEncrypt(next->key, next->counter, next->out);

	/* Increment next.counter as an 128-bit single quantity in network
	   byte order for AES counter mode. */
	for (j = 15; j >= 0; j--)
		if (++next->counter[j])
			break;
	return OWPraw2num64((next->out) + 4*res);
}

/*
** Seed the random number generator using a 16-byte string.
*/
void
OWPrand_context64_init(OWPrand_context64 *next, BYTE *seed)
{
	int i;

	/* Initialize the key */
	rijndaelKeyInit(next->key, seed);

	memset(next->out, 0, 16);
	for (i = 0; i < 16; i++)
		next->counter[i] = 0UL;
}

/* 
** Generate an exponential deviate using a 32-bit binary string as an input
** This is algorithm 3.4.1.S from Knuth's v.2 of "Art of Computer Programming" 
** (1998), p.133.
*/
OWPnum64 
OWPexp_rand64(OWPrand_context64 *next)
{
	unsigned long i, k;
	u_int32_t j = 0;
	OWPnum64 U, V, J, tmp; 
	u_int32_t mask = 0x80000000; /* see if first bit in the lower
			   		     32 bits is zero */

	/* Get U and shift */
	U = OWPunif_rand64(next);

	while (U & mask && j < 32){ /* shift until find first '0' */
		U <<= 1;
		j++;
	}
	/* remove the '0' itself */
	U <<= 1;
	
	U &= 0xFFFFFFFF;  /* Keep only the fractional part. */
	J = OWPulong2num64(j);
	
	/* Immediate acceptance? */
	if (U < LN2) 	   /* return  (j*ln2 + U) */ 
		return OWPnum64_add(OWPnum64_mul(J, LN2), U);   

	/* Minimize */
	for (k = 2; k < K; k++)
		if (U < Q[k])
			break;
	V = OWPunif_rand64(next);
	for (i = 2; i <= k; i++){
		tmp = OWPunif_rand64(next);
		if (tmp < V)
			V = tmp;
	}

	/* Return (j+V)*ln2 */
	return OWPnum64_mul(OWPnum64_add(J, V), LN2);
}

/*
** Print out a OWPnum64 number - used for debugging.
*/
void
OWPnum_print64(OWPnum64 x)
{
	fprintf(stdout, "%llX \n", x);
}


